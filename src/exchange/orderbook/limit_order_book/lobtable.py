from .helpers.order_checker import OrderChecker
from .helpers.transaction_calculator import TransactionCalculator
from .helpers.order_dispatcher import OrderDispatcher
from .helpers.queue_operator import QueueOperator
from .helpers.queue_observer import QueueObserver
from .helpers.order_processor import OrderProcessor
from src.exchange.orders.initial_order_creator import InitialOrderCreator
from src.utils.debug import Debug
import heapq


class LOBTable(Debug):
    """
    BidAsk Table: Implements a CAD (Continuous Double Auction), matching pair of orders.
    The CAD can Accept, Reject or Complete each order.
    The CAD changes it's internal state through the update method. It returns information about the changes made
    Attributes
    ----------
    contract : str
        each LOBTable manages a specific contract, uniquely identified by a string value
    current_time : float
        keep track of simulation time
    bid : PriorityQueue
        keep all the bid offers, sorted from best to worse (Limit orders)
    market_bid : PriorityQueue
        keep all the bid offers, sorted from best to worse (Market orders)
    ask : PriorityQueue
        keep all the ask offers, sorted from best to worse (Limit orders)
    market_ask : PriorityQueue
        keep all the ask offers, sorted from best to worse (Market orders)
    stop : List
        keep all the stop orders, that are eventually pushed to the Market order queue or Limit order queue
    keep_partials : bool
        determines if orders that are only partially executed have to be kept in the queue
    order_checker : OrderChecker
        Handles the checked_expired and check_classified methods
    Methods
    -------
    handle_order: Order
        dispatch new order to be processed. Return notification generated by the processing engine
    handle_expirations: Float
        updates all expired orders, using the current_time of the simulation
    """
    def __init__(self, contract):
        super(LOBTable, self).__init__()
        self.contract = contract
        self.tick_size = 1/16.   # TODO: = np.round(__, 2)
        self.current_time = None
        self.all_orders_history = []

        self.bid = []
        self.ask = []
        self.market_bid = []
        self.market_ask = []
        self.stop = []
        self.expiration_times = []
        # TODO: remove?
        self.expired_not_notified = []

        self.keep_partials = True
        self.allow_duplicated_ids = False

        # Order processing
        # Order checking
        self.order_checker = OrderChecker(self, QueueObserver(self))
        self.order_dispatcher = OrderDispatcher(self, QueueOperator(self),
                                                OrderProcessor(self, TransactionCalculator(), QueueOperator(self)))
        # Queue processing (uses order processing)
        self.queue_observer = QueueObserver(self)
        self.queue_operator = QueueOperator(self)

        # Additional information
        self.history_order_notification = []
        self.spread_history = []
        self.limit_orders_history = []
        self.market_orders_history = []
        self.stop_orders_history = []

        self.debug('Bid Ask Table Initialized')

    def get_identifier(self):
        return "lob_" + self.contract

    def get_orders_history(self):
        return self.all_orders_history

    def get_limit_orders_history(self):
        return self.limit_orders_history

    def get_stop_orders_history(self):
        return self.stop_orders_history

    def get_market_orders_history(self):
        return self.market_orders_history

    def set_initial_orders(self, initial_orders):
        queue_operator = QueueOperator(self)
        for order_id, order_params in enumerate(initial_orders):
            order = InitialOrderCreator.create_order(self.contract, order_id, order_params)
            queue_operator.push(order)
        return 0

    def set_tick_size(self, tick_size):
        assert 0 < tick_size <= 1
        self.tick_size = tick_size
        return 0

    def get_current_time(self):
        return self.current_time

    def update_orders_history(self):
        new_snapshot_limit = []
        for order in self.bid + self.ask:
            new_snapshot_limit.append((order.direction.name, order.get_price(), order.get_size_remaining()))
        self.limit_orders_history.append((self.current_time, new_snapshot_limit))
        # Add snapshot of market book
        new_snapshot_market = []
        for order in self.market_bid + self.market_ask:
            new_snapshot_market.append((order.direction.name, order.get_price(), order.get_size_remaining()))
        self.market_orders_history.append((self.current_time, new_snapshot_market))
        # Add snapshot of stop book
        new_snapshot_stop = []
        for order in self.stop:
            new_snapshot_stop.append((order.direction.name, order.get_price(), order.get_size_remaining()))
        self.stop_orders_history.append((self.current_time, new_snapshot_stop))
        return 0

    def update_history(self):
        # TODO: GUARDAR MARKET ORDERS! (no se guardan ahora xq ejecutan al toque)
        self.update_spread_history()
        self.update_orders_history()
        return 0

    def get_spread_history(self):
        return self.spread_history

    def update_history_order_notification(self, order, notification):
        """
        Keep track of every order and it's effect on the orderbook
        :param order:
        :param notification:
        :return:
        """
        self.history_order_notification.append((order, notification))
        return 0

    def update_spread_history(self):
        if self.queue_observer.ask_empty() or self.queue_observer.bid_empty():
            self.spread_history += [(self.current_time, None)]
        else:
            best_bid = self.queue_observer.best_bid()
            best_ask = self.queue_observer.best_ask()
            self.spread_history += [(self.current_time, (best_bid.price, best_ask.price))]
        return 0

    def handle_expirations(self, current_time):
        orders_expired = []
        checking = True
        while checking and len(self.expiration_times) > 0:
            expiration_time, order_id = heapq.nsmallest(1, self.expiration_times)[0]
            if expiration_time <= current_time:
                # Remove this expiration time
                heapq.heappop(self.expiration_times)
                # Fetch corresponding order and remove it (Limit,Market[Ask])
                keep_looking, order = self.queue_operator.pop_ask_by_id(order_id)
                if not keep_looking:
                    # Fetch corresponding order and remove it (Limit,Market[Bid]
                    keep_looking, order = self.queue_operator.pop_bid_by_id(order_id)
                if not keep_looking:
                    # Remove the order if it is in the stop queue
                    order_match = [order for order in self.stop if order.m_orderId == order_id]
                    if len(order_match) > 0:
                        self.stop = [order for order in self.stop if order.m_orderId != order_id]
                        order = order_match[0]
                        # order.expired()
                if order is not None:
                    # Remove that expiration
                    order.expired()
                    orders_expired.append(order)
            else:
                checking = False
        return orders_expired

    def handle_order(self, order, current_time):
        """
        Instantly updates bid, ask agents_data structures. Returns matched orders and status of orders
        Note: some matchings can be only partially executed because not enough volume in one leg.
        """
        # Checking some things
        if self.current_time is None:
            self.current_time = current_time
        elif current_time < self.current_time:
            raise Exception("Timestamp that has passed: %f vs. %f" % (current_time, self.current_time))
        self.current_time = current_time

        # Log received order
        self.all_orders_history.append(order)

        # Handle expirations and after that, dispatch the new order
        expired_orders = self.handle_expirations(current_time)
        notification = self.order_dispatcher.dispatch_order(order)
        notification.append(expired=expired_orders)

        # Update internal information for analysis
        self.update_history()
        return notification
